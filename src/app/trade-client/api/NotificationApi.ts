/**
 * TraDE Middleware API
 * This is the API of the TraDE middleware.
 *
 * OpenAPI spec version: 0.0.1
 * Contact: trade4chor@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class NotificationApi {

    protected basePath = 'https://localhost/api';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * 
     * @summary Creates and adds a new notification to the TraDE middleware
     * @param notificationData A name, notifier service id and an array of corresponding notifier parameter values are required. Furthermore, the id of the resource to observe, i.e., the resource for which this notification is registered or an array of resource filtes has to be provided. The resource filters allow to specify filter criteria which is evaluated in order to decide if a notification is triggered as a result of an event (e.g., state of a resource changed) or not.
     */
    public addNotification(notificationData: models.NotificationData, extraHttpRequestParams?: any): Observable<models.Notification> {
        return this.addNotificationWithHttpInfo(notificationData, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Deletes a notification from the TraDE middleware.
     * @summary Deletes a notification
     * @param notificationId Id of the notification that needs to be fetched
     */
    public deleteNotification(notificationId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteNotificationWithHttpInfo(notificationId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Find a notification by Id
     * @param notificationId Id of the notification that needs to be fetched
     */
    public getNotificationDirectly(notificationId: string, extraHttpRequestParams?: any): Observable<models.NotificationWithLinks> {
        return this.getNotificationDirectlyWithHttpInfo(notificationId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Gets all available `Notification` resources. Optional query parameter of **start** and **size** enable pagination of the collection of notification resources, param **name** filters result list by the name and param **notifierServiceId** filters result list by the associated notifier service of the notification.
     * @param start Start index of returned collection of resources for pagination.
     * @param size Size of the returned sub-collection of resources for pagination.
     * @param name Name of notifications to return
     * @param notifierServiceId The id of the notifier service used by a notification
     */
    public getNotifications(start?: number, size?: number, name?: string, notifierServiceId?: string, extraHttpRequestParams?: any): Observable<models.NotificationArrayWithLinks> {
        return this.getNotificationsWithHttpInfo(start, size, name, notifierServiceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Update an existing notification
     * @param notificationId Id of the notification that needs to be fetched
     * @param notification The updated notification resource. Changes to the fields **id** and **href** are ignored since the corresponding fields of the resource are internally set by the server.
     */
    public updateNotificationDirectly(notificationId: string, notification: models.Notification, extraHttpRequestParams?: any): Observable<models.NotificationWithLinks> {
        return this.updateNotificationDirectlyWithHttpInfo(notificationId, notification, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Creates and adds a new notification to the TraDE middleware
     * 
     * @param notificationData A name, notifier service id and an array of corresponding notifier parameter values are required. Furthermore, the id of the resource to observe, i.e., the resource for which this notification is registered or an array of resource filtes has to be provided. The resource filters allow to specify filter criteria which is evaluated in order to decide if a notification is triggered as a result of an event (e.g., state of a resource changed) or not.
     */
    public addNotificationWithHttpInfo(notificationData: models.NotificationData, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/notifications';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'notificationData' is not null or undefined
        if (notificationData === null || notificationData === undefined) {
            throw new Error('Required parameter notificationData was null or undefined when calling addNotification.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: notificationData == null ? '' : JSON.stringify(notificationData), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Deletes a notification
     * Deletes a notification from the TraDE middleware.
     * @param notificationId Id of the notification that needs to be fetched
     */
    public deleteNotificationWithHttpInfo(notificationId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/notifications/${notificationId}'
                    .replace('${' + 'notificationId' + '}', String(notificationId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'notificationId' is not null or undefined
        if (notificationId === null || notificationId === undefined) {
            throw new Error('Required parameter notificationId was null or undefined when calling deleteNotification.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Find a notification by Id
     * 
     * @param notificationId Id of the notification that needs to be fetched
     */
    public getNotificationDirectlyWithHttpInfo(notificationId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/notifications/${notificationId}'
                    .replace('${' + 'notificationId' + '}', String(notificationId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'notificationId' is not null or undefined
        if (notificationId === null || notificationId === undefined) {
            throw new Error('Required parameter notificationId was null or undefined when calling getNotificationDirectly.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Gets all available &#x60;Notification&#x60; resources. Optional query parameter of **start** and **size** enable pagination of the collection of notification resources, param **name** filters result list by the name and param **notifierServiceId** filters result list by the associated notifier service of the notification.
     * @param start Start index of returned collection of resources for pagination.
     * @param size Size of the returned sub-collection of resources for pagination.
     * @param name Name of notifications to return
     * @param notifierServiceId The id of the notifier service used by a notification
     */
    public getNotificationsWithHttpInfo(start?: number, size?: number, name?: string, notifierServiceId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/notifications';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (notifierServiceId !== undefined) {
            queryParameters.set('notifierServiceId', <any>notifierServiceId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update an existing notification
     * 
     * @param notificationId Id of the notification that needs to be fetched
     * @param notification The updated notification resource. Changes to the fields **id** and **href** are ignored since the corresponding fields of the resource are internally set by the server.
     */
    public updateNotificationDirectlyWithHttpInfo(notificationId: string, notification: models.Notification, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/notifications/${notificationId}'
                    .replace('${' + 'notificationId' + '}', String(notificationId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'notificationId' is not null or undefined
        if (notificationId === null || notificationId === undefined) {
            throw new Error('Required parameter notificationId was null or undefined when calling updateNotificationDirectly.');
        }
        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling updateNotificationDirectly.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: notification == null ? '' : JSON.stringify(notification), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
