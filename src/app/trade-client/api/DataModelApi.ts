/**
 * TraDE Middleware API
 * This is the API of the TraDE middleware.
 *
 * OpenAPI spec version: 0.0.1
 * Contact: trade4chor@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DataModelApi {

    protected basePath = 'https://localhost/api';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * 
     * @summary Creates and adds a new data model to the TraDE middleware
     * @param dataModelData The name and creating entity of the data model that will be created.
     */
    public addDataModel(dataModelData: models.DataModelData, extraHttpRequestParams?: any): Observable<models.DataModel> {
        return this.addDataModelWithHttpInfo(dataModelData, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Deletes a data model and all resources related to it from the TraDE middleware. This means that all data objects and their data elements defined through this data model as well as their instances will be deleted. Therefore, the deletion of a data model should be handled with care since it is one of the core artifacts used by the TraDE middleware.
     * @summary Deletes a data model and all related resources.
     * @param dataModelId Id of the data model that needs to be fetched
     */
    public deleteDataModel(dataModelId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteDataModelWithHttpInfo(dataModelId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Provides the serialized data model
     * @param dataModelId Id of the data model that needs to be fetched
     */
    public downloadDataModel(dataModelId: string, extraHttpRequestParams?: any): Observable<string> {
        return this.downloadDataModelWithHttpInfo(dataModelId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Get the data model associated to the data dependency graph.
     * @param graphId Id of the data dependency graph that needs to be fetched
     */
    public getDataModel(graphId: string, extraHttpRequestParams?: any): Observable<models.DataModelWithLinks> {
        return this.getDataModelWithHttpInfo(graphId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Find a data model by Id
     * @param dataModelId Id of the data model that needs to be fetched
     */
    public getDataModelDirectly(dataModelId: string, extraHttpRequestParams?: any): Observable<models.DataModelWithLinks> {
        return this.getDataModelDirectlyWithHttpInfo(dataModelId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Gets all available `DataModel` resources. Optional query parameter of **start** and **size** enable pagination of the collection of data model resources and param **targetNamespace**, **name** and **entity** filter result list by name, targetNamespace and entity.
     * @param start Start index of returned collection of resources for pagination.
     * @param size Size of the returned sub-collection of resources for pagination.
     * @param targetNamespace Target namespace of data model to return
     * @param name Name of data model to return
     * @param entity Creating entity of data dependency graph to return
     */
    public getDataModels(start?: number, size?: number, targetNamespace?: string, name?: string, entity?: string, extraHttpRequestParams?: any): Observable<models.DataModelArrayWithLinks> {
        return this.getDataModelsWithHttpInfo(start, size, targetNamespace, name, entity, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Associates an existing dataModel to the data dependency graph.
     * @param graphId Id of the data dependency graph that needs to be fetched
     * @param dataModelId The id of a data model that should be associated to this data dependency graph.
     */
    public setDataModel(graphId: string, dataModelId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.setDataModelWithHttpInfo(graphId, dataModelId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Upload a serialized data model to the TraDE middleware in order to make it available.
     * @param dataModelId Id of the data model that needs to be fetched
     * @param contentLength The size of the serialized data model passed as header
     * @param model The serialized data model to upload.
     */
    public uploadDataModel(dataModelId: string, contentLength: number, model: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.uploadDataModelWithHttpInfo(dataModelId, contentLength, model, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Creates and adds a new data model to the TraDE middleware
     * 
     * @param dataModelData The name and creating entity of the data model that will be created.
     */
    public addDataModelWithHttpInfo(dataModelData: models.DataModelData, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dataModels';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'dataModelData' is not null or undefined
        if (dataModelData === null || dataModelData === undefined) {
            throw new Error('Required parameter dataModelData was null or undefined when calling addDataModel.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: dataModelData == null ? '' : JSON.stringify(dataModelData), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Deletes a data model and all related resources.
     * Deletes a data model and all resources related to it from the TraDE middleware. This means that all data objects and their data elements defined through this data model as well as their instances will be deleted. Therefore, the deletion of a data model should be handled with care since it is one of the core artifacts used by the TraDE middleware.
     * @param dataModelId Id of the data model that needs to be fetched
     */
    public deleteDataModelWithHttpInfo(dataModelId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dataModels/${dataModelId}'
                    .replace('${' + 'dataModelId' + '}', String(dataModelId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'dataModelId' is not null or undefined
        if (dataModelId === null || dataModelId === undefined) {
            throw new Error('Required parameter dataModelId was null or undefined when calling deleteDataModel.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Provides the serialized data model
     * 
     * @param dataModelId Id of the data model that needs to be fetched
     */
    public downloadDataModelWithHttpInfo(dataModelId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dataModels/${dataModelId}/serialized-model'
                    .replace('${' + 'dataModelId' + '}', String(dataModelId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'dataModelId' is not null or undefined
        if (dataModelId === null || dataModelId === undefined) {
            throw new Error('Required parameter dataModelId was null or undefined when calling downloadDataModel.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/octet-stream'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get the data model associated to the data dependency graph.
     * 
     * @param graphId Id of the data dependency graph that needs to be fetched
     */
    public getDataModelWithHttpInfo(graphId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dataDependencyGraphs/${graphId}/dataModel'
                    .replace('${' + 'graphId' + '}', String(graphId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'graphId' is not null or undefined
        if (graphId === null || graphId === undefined) {
            throw new Error('Required parameter graphId was null or undefined when calling getDataModel.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Find a data model by Id
     * 
     * @param dataModelId Id of the data model that needs to be fetched
     */
    public getDataModelDirectlyWithHttpInfo(dataModelId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dataModels/${dataModelId}'
                    .replace('${' + 'dataModelId' + '}', String(dataModelId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'dataModelId' is not null or undefined
        if (dataModelId === null || dataModelId === undefined) {
            throw new Error('Required parameter dataModelId was null or undefined when calling getDataModelDirectly.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Gets all available &#x60;DataModel&#x60; resources. Optional query parameter of **start** and **size** enable pagination of the collection of data model resources and param **targetNamespace**, **name** and **entity** filter result list by name, targetNamespace and entity.
     * @param start Start index of returned collection of resources for pagination.
     * @param size Size of the returned sub-collection of resources for pagination.
     * @param targetNamespace Target namespace of data model to return
     * @param name Name of data model to return
     * @param entity Creating entity of data dependency graph to return
     */
    public getDataModelsWithHttpInfo(start?: number, size?: number, targetNamespace?: string, name?: string, entity?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dataModels';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (start !== undefined) {
            queryParameters.set('start', <any>start);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (targetNamespace !== undefined) {
            queryParameters.set('targetNamespace', <any>targetNamespace);
        }

        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (entity !== undefined) {
            queryParameters.set('entity', <any>entity);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Associates an existing dataModel to the data dependency graph.
     * 
     * @param graphId Id of the data dependency graph that needs to be fetched
     * @param dataModelId The id of a data model that should be associated to this data dependency graph.
     */
    public setDataModelWithHttpInfo(graphId: string, dataModelId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dataDependencyGraphs/${graphId}/dataModel'
                    .replace('${' + 'graphId' + '}', String(graphId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'graphId' is not null or undefined
        if (graphId === null || graphId === undefined) {
            throw new Error('Required parameter graphId was null or undefined when calling setDataModel.');
        }
        // verify required parameter 'dataModelId' is not null or undefined
        if (dataModelId === null || dataModelId === undefined) {
            throw new Error('Required parameter dataModelId was null or undefined when calling setDataModel.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: dataModelId == null ? '' : JSON.stringify(dataModelId), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Upload a serialized data model to the TraDE middleware in order to make it available.
     * 
     * @param dataModelId Id of the data model that needs to be fetched
     * @param contentLength The size of the serialized data model passed as header
     * @param model The serialized data model to upload.
     */
    public uploadDataModelWithHttpInfo(dataModelId: string, contentLength: number, model: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/dataModels/${dataModelId}/serialized-model'
                    .replace('${' + 'dataModelId' + '}', String(dataModelId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'dataModelId' is not null or undefined
        if (dataModelId === null || dataModelId === undefined) {
            throw new Error('Required parameter dataModelId was null or undefined when calling uploadDataModel.');
        }
        // verify required parameter 'contentLength' is not null or undefined
        if (contentLength === null || contentLength === undefined) {
            throw new Error('Required parameter contentLength was null or undefined when calling uploadDataModel.');
        }
        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling uploadDataModel.');
        }
        if (contentLength !== undefined && contentLength !== null) {
            headers.set('Content-Length', String(contentLength));
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/octet-stream'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: model == null ? '' : JSON.stringify(model), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
