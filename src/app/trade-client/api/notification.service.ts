/**
 * TraDE Middleware API
 * This is the API of the TraDE middleware.
 *
 * OpenAPI spec version: 0.0.1
 * Contact: trade4chor@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { InvalidInput } from '../model/invalidInput';
import { NotFound } from '../model/notFound';
import { Notification } from '../model/notification';
import { NotificationArrayWithLinks } from '../model/notificationArrayWithLinks';
import { NotificationData } from '../model/notificationData';
import { NotificationWithLinks } from '../model/notificationWithLinks';

import { TRADE_BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class NotificationService {

    protected basePath = 'https://localhost/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(TRADE_BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Creates and adds a new notification to the TraDE middleware
     * 
     * @param notificationData A name, notifier service id and an array of corresponding notifier parameter values are required. Furthermore, the id of the resource to observe, i.e., the resource for which this notification is registered or an array of resource filtes has to be provided. The resource filters allow to specify filter criteria which is evaluated in order to decide if a notification is triggered as a result of an event (e.g., state of a resource changed) or not.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addNotification(notificationData: NotificationData, observe?: 'body', reportProgress?: boolean): Observable<Notification>;
    public addNotification(notificationData: NotificationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Notification>>;
    public addNotification(notificationData: NotificationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Notification>>;
    public addNotification(notificationData: NotificationData, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (notificationData === null || notificationData === undefined) {
            throw new Error('Required parameter notificationData was null or undefined when calling addNotification.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Notification>(`${this.basePath}/notifications`,
            notificationData,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a notification
     * Deletes a notification from the TraDE middleware.
     * @param notificationId Id of the notification that needs to be fetched
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteNotification(notificationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteNotification(notificationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteNotification(notificationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteNotification(notificationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (notificationId === null || notificationId === undefined) {
            throw new Error('Required parameter notificationId was null or undefined when calling deleteNotification.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/notifications/${encodeURIComponent(String(notificationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find a notification by Id
     * 
     * @param notificationId Id of the notification that needs to be fetched
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNotificationDirectly(notificationId: string, observe?: 'body', reportProgress?: boolean): Observable<NotificationWithLinks>;
    public getNotificationDirectly(notificationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NotificationWithLinks>>;
    public getNotificationDirectly(notificationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationWithLinks>>;
    public getNotificationDirectly(notificationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (notificationId === null || notificationId === undefined) {
            throw new Error('Required parameter notificationId was null or undefined when calling getNotificationDirectly.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<NotificationWithLinks>(`${this.basePath}/notifications/${encodeURIComponent(String(notificationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Gets all available &#x60;Notification&#x60; resources. Optional query parameter of **start** and **size** enable pagination of the collection of notification resources, param **name** filters result list by the name and param **notifierServiceId** filters result list by the associated notifier service of the notification.
     * @param start Start index of returned collection of resources for pagination.
     * @param size Size of the returned sub-collection of resources for pagination.
     * @param name Name of notifications to return
     * @param notifierServiceId The id of the notifier service used by a notification
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNotifications(start?: number, size?: number, name?: string, notifierServiceId?: string, observe?: 'body', reportProgress?: boolean): Observable<NotificationArrayWithLinks>;
    public getNotifications(start?: number, size?: number, name?: string, notifierServiceId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NotificationArrayWithLinks>>;
    public getNotifications(start?: number, size?: number, name?: string, notifierServiceId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationArrayWithLinks>>;
    public getNotifications(start?: number, size?: number, name?: string, notifierServiceId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (start !== undefined) {
            queryParameters = queryParameters.set('start', <any>start);
        }
        if (size !== undefined) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (name !== undefined) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (notifierServiceId !== undefined) {
            queryParameters = queryParameters.set('notifierServiceId', <any>notifierServiceId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<NotificationArrayWithLinks>(`${this.basePath}/notifications`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update an existing notification
     * 
     * @param notificationId Id of the notification that needs to be fetched
     * @param notification The updated notification resource. Changes to the fields **id** and **href** are ignored since the corresponding fields of the resource are internally set by the server.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateNotificationDirectly(notificationId: string, notification: Notification, observe?: 'body', reportProgress?: boolean): Observable<NotificationWithLinks>;
    public updateNotificationDirectly(notificationId: string, notification: Notification, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NotificationWithLinks>>;
    public updateNotificationDirectly(notificationId: string, notification: Notification, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationWithLinks>>;
    public updateNotificationDirectly(notificationId: string, notification: Notification, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (notificationId === null || notificationId === undefined) {
            throw new Error('Required parameter notificationId was null or undefined when calling updateNotificationDirectly.');
        }
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling updateNotificationDirectly.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<NotificationWithLinks>(`${this.basePath}/notifications/${encodeURIComponent(String(notificationId))}`,
            notification,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
